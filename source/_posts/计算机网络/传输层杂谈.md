---
title: 传输层杂谈
categories: 计算机网络
tags: [计算机网络, TCP, UDP, 传输层]
copyright_author: 崔帆
copyright_author_href: https://xxxxxx.com
copyright_url: https://xxxxxx.com
top_img: /images/tcp1.webp
cover: /images/tcp1.webp
copyright_info: 此文章版权归崔帆所有，如有转载，请注明来自原作者
---
## 1. TCP和UDP的区别

TCP是一个**面向连接的、可靠的、基于字节流的**传输层通信协议。UDP是一个**面向无连接的**的传输层协议。具体来分析，TCP的三大特性如下：

-   **面向连接**。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。
-   **可靠性**。TCP花了很多的功夫保证连接的可靠。可靠性体现在**有状态**、**可控制**。TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且**保证数据包按序到达**，不允许半点差错。这是**有状态**。当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是**可控制**。
-   **面向字节流**。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。

## 2. TCP三次握手

详见我的文章[05 浅谈传输层协议](https://juejin.cn/post/7108665122406531085)，这里主要谈一些疑问。

![07-2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3f0b2e2174c477bba2ef60f019119a0~tplv-k3u1fbpfcp-watermark.image?)
### 为什么不是两次？

前面提到过，TCP三次握手本质是**确认初始序列号**的过程。只有两次握手的话，服务器发送的初始序号没有被客户端确认。因此无法确认客户端的接收能力。但，如果是两次会怎样呢？

如果是两次，你现在发了 SYN 报文想握手，但是这个包**滞留**在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。

看似没有问题，但是连接关闭后，如果这个**滞留**在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认**建立连接**，但是现在客户端已经断开了。这就带来了连接资源的浪费。

### 为什么不是四次？

三次就足够了，再多用处就不大了。

### 第三次握手携带数据？

第三次握手的时候，可以携带。前两次握手不能携带数据。

如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的**时间**和**内存空间**去处理这些数据，增大了服务器被攻击的风险。

第三次握手的时候，客户端已经处于`ESTABLISHED`状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

### 同时打开会怎么样？

如果双方同时发 `SYN`报文，状态变化会是怎样的呢？

这是一个可能会发生的情况。
![07-1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4099f40c334845209cffa9b3c5699709~tplv-k3u1fbpfcp-watermark.image?)

在发送方给接收方发`SYN`报文的同时，接收方也给发送方发`SYN`报文。发完`SYN`，两者的状态都变为`SYN-SENT`。在各自收到对方的`SYN`后，两者状态都变为`SYN-REVD`。接着会回复对应的`ACK + SYN`，这个报文在对方接收之后，两者状态一起变为`ESTABLISHED`。

## 3. TCP四次挥手

详见我的文章[05 浅谈传输层协议](https://juejin.cn/post/7108665122406531085)，这里主要谈一些疑问。

![07-3.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61258948543343ec98ee6b555a7f2bfd~tplv-k3u1fbpfcp-watermark.image?)
### 等待2MSL的意义？

#### 不等待会怎么样？

-   客户端不确认最后一个ACK包服务器是否收到，如果没收到，服务器不会正常关闭。
-   服务端发送给客户端的数据包可能还在路上(和服务器的FIN报文一起)，如果不等待，客户端关闭。新的端口被占用的话会受到许多 无用的数据包，造成数据包混乱和丢失。

#### 为什么是2MSL？

设置2MSL，服务器会在2MSL时间内超时重传。1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端。1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达。

### 为什么是四次而不是三次？

#### 为什么是四次？

四次挥手是为了确认通信双方都关闭，而不是出现半关闭的情况出现。服务端在接收到`FIN`, 往往不会立即返回`FIN`, 必须等到服务端所有的报文都发送完毕了，才能发`FIN`。因此先发一个`ACK`表示已经收到客户端的`FIN`，延迟一段时间才发`FIN`。这就造成了四次挥手。

#### 三次挥手有什么问题？

等于说服务端将`ACK`和`FIN`的发送合并为一次挥手，这个时候长时间的延迟(服务器先把自己的数据发完再发挥手报文)可能会导致客户端误以为`FIN`没有到达客户端，从而让客户端不断的重发`FIN`。

### 同时关闭会怎样？

![07-4.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19da59b814da424c95e7aedc9c9bb907~tplv-k3u1fbpfcp-watermark.image?)

## 4. SYN Flood攻击

三次握手前，服务端的状态从`CLOSED`变为`LISTEN`, 同时在内部创建了两个队列：**半连接队列**和**全连接队列**，即**SYN队列**和**ACCEPT队列**。

### 半连接队列

当客户端发送`SYN`到服务端，服务端收到以后回复`ACK`和`SYN`，状态由`LISTEN`变为`SYN_RCVD`，此时这个连接就被推入了**SYN队列**，也就是**半连接队列**。

### 全连接队列

当客户端返回`ACK`, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是**全连接队列**。

### SYN Flood攻击原理

属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送`SYN`。对于服务端而言，会产生两个危险的后果:

0.  处理大量的`SYN`包并返回对应`ACK`, 势必有大量连接处于`SYN_RCVD`状态，从而占满整个**半连接队列**，无法处理正常的请求。
0.  由于是不存在的 IP，服务端长时间收不到客户端的`ACK`，会导致服务端不断重发数据，直到耗尽服务端的资源。

### 如何应对SYN Flood攻击？

![07-5.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bd25483919b422ea3be927400b085d3~tplv-k3u1fbpfcp-watermark.image?)

0.  增加 SYN 连接，也就是增加半连接队列的容量。
0.  减少 SYN + ACK 重试次数，避免大量的超时重发。
0.  利用 `SYN Cookie`技术，在服务端接收到`SYN`后不立即分配连接资源，而是根据这个`SYN`计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复`ACK`的时候带上这个`Cookie`值，服务端验证 Cookie 合法之后才分配连接资源。

## 5. TCP头部字段

![07-6.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc30c5c444e42cc800fe4ffc61554d7~tplv-k3u1fbpfcp-watermark.image?)

### 源端口、目标端口

如何标识唯一标识一个连接？答案是 TCP 连接的`四元组`——源 IP、源端口、目标 IP 和目标端口。

那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP 。TCP 只需要记录两者的端口即可。

### 序列号

即`Sequence number`, 指的是本报文段第一个字节的序列号。从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 0 ~ 2^32 - 1。如果到达最大值了后就循环到0。

序列号在 TCP 通信的过程中有两个作用:

0.  在 SYN 报文中交换彼此的初始序列号。
0.  保证数据包按正确的顺序组装。

### ISN

即`Initial Sequence Number（初始序列号）`,在三次握手的过程当中，双方会用过`SYN`报文来交换彼此的 `ISN`。

ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。那为什么要这么做？

如果 ISN 被攻击者预测到，要知道**源 IP 和源端口号都是很容易伪造的**，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。

而动态增长的 ISN 大大提高了猜测 ISN 的难度。

### 确认号

即`ACK(Acknowledgment number)`。用来告知对方下一个期望接收的序列号，**小于ACK**的所有字节已经全部收到。

### 标记位

常见的标记位有`SYN`,`ACK`,`FIN`,`RST`,`PSH`。

SYN 和 ACK 已经在上文说过，后三个解释如下: `FIN`： 即 Finish，表示发送方准备断开连接。

`RST`：即 Reset，用来强制断开连接。

`PSH`： 即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。

### 窗口大小

占用两个字节，也就是 16 位，但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。

### 校验和

占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传。

### 可选项

格式如下：

| 种类（Kind）1 byte | 长度（Length）1 byte | 值（value） |
| -------------- | ---------------- | -------- |
|                |                  |          |

常用的可选项有以下几个:

-   TimeStamp：TCP 时间戳，后面详细介绍。
-   SACK：选择确认选项。
-   Window Scale：窗口缩放选项。
-   MSS：指的是 TCP 允许的从对方接收的最大报文段。

## 6. TCP快速打开原理(TFO)

![07-7.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6606a995d87c419e90bcd6352ad550e4~tplv-k3u1fbpfcp-watermark.image?)

TFO实现借助于`SYN Cookie`。
### TFO流程

#### 首轮三次握手

客户端发送SYN给服务端，服务端接收到。服务端不是立刻回复 SYN + ACK，而是通过计算得到一个`SYN Cookie`, 将这个`Cookie`放到 TCP 报文的 `Fast Open`选项中，然后才给客户端返回。客户端拿到这个 Cookie 的值缓存下来。后面正常完成三次握手。

#### 后面的三次握手

在后面的三次握手中，客户端会将之前缓存的 `SYN Cookie`、`SYN` 和`HTTP请求`(是的，你没看错)发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回`SYN + ACK`。

重点来了，现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。

当然，客户端的`ACK`还得正常传过来，不然怎么叫三次握手嘛。

注意: 客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。

### TFO的优势

TFO 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了**1 个RTT**(Round-Trip Time，往返时延)的时间**提前进行数据传输**，积累起来还是一个比较大的优势。

## 7. TCP报文时间戳的作用

`timestamp`是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下:

```
kind(1 字节) + length(1 字节) + info(8 个字节)
```

其中 kind = 8， length = 10， info 有两部分构成: **timestamp**和**timestamp echo**，各占 4 个字节。

TCP 的时间戳主要解决两大问题：

-   计算往返时延 RTT(Round-Trip Time)
-   防止序列号的回绕问题

### 计算往返时延RTT

![07-8.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc657088b98c4dd38f0ca2e9e1300996~tplv-k3u1fbpfcp-watermark.image?)

如果以第一次发包为开始时间的话，就会出现左图的问题，RTT 明显偏大，开始时间应该采用第二次的；

如果以第二次发包为开始时间的话，就会导致右图的问题，RTT 明显偏小，开始时间应该采用第一次发包的。

实际上无论开始时间以第一次发包还是第二次发包为准，都是不准确的。

引入时间戳就很好的解决了这个问题。

比如现在 a 向 b 发送一个报文 s1，b 向 a 回复一个含 ACK 的报文 s2 那么：

**step 1:** a 向 b 发送的时候，`timestamp` 中存放的内容就是 a 主机发送时的内核时刻 `ta1`。

**step 2:** b 向 a 回复 s2 报文的时候，`timestamp` 中存放的是 b 主机的时刻 `tb`, `timestamp echo`字段为从 s1 报文中解析出来的 ta1。

**step 3:** a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 ta2, 而在 s2 报文中的 timestamp echo 选项中可以得到 `ta1`, 也就是 s2 对应的报文最初的发送时刻。然后直接采用 ta2 - ta1 就得到了 RTT 的值。

### 防止序列号回绕问题

序列号的范围其实是在0 ~ 2 ^ 32 - 1, 为了方便演示，我们缩小一下这个区间，假设范围是 0 ~ 4，那么到达 4 的时候会回到 0。

| 第几次发包 | 发送字节  | 对应序列号 | 状态           |
| ----- | ----- | ----- | ------------ |
| 1     | 0 ~ 1 | 0 ~ 1 | 成功接收         |
| 2     | 1 ~ 2 | 1 ~ 2 | 滞留在网络中       |
| 3     | 2 ~ 3 | 2 ~ 3 | 成功接收         |
| 4     | 3 ~ 4 | 3 ~ 4 | 成功接收         |
| 5     | 4 ~ 5 | 0 ~ 1 | 成功接收，序列号从0开始 |
| 6     | 5 ~ 6 | 1 ~ 2 | ？？？          |

假设在第 6 次的时候，之前还滞留在网路中的包回来了，那么就有两个序列号为`1 ~ 2`的数据包了，怎么区分谁是谁呢？这个时候就产生了序列号回绕的问题。

那么用 timestamp 就能很好地解决这个问题，因为每次发包的时候都是将发包机器当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了。

## 8. 计算TCP超时重传时间

它的计算跟上一节提到的 RTT 密切相关。这里我们将介绍两种主要的方法，一个是经典方法，一个是标准方法。

### 经典方法

经典方法引入了一个新的概念——SRTT(Smoothed round trip time，即平滑往返时间)，每产生一次新的 RTT. 就根据一定的算法对 SRTT 进行更新，具体而言，计算方式如下(SRTT 初始值为0)：

```
SRTT =  (α * SRTT) + ((1 - α) * RTT)
```

其中，α 是**平滑因子**，建议值是`0.8`，范围是`0.8 ~ 0.9`。

拿到 SRTT，我们就可以计算 RTO 的值了:

```
RTO = min(ubound, max(lbound, β * SRTT))
```

β 是加权因子，一般为`1.3 ~ 2.0`， **lbound** 是下界，**ubound** 是上界。

其实这个算法过程还是很简单的，但是也存在一定的局限，就是在 RTT 稳定的地方表现还可以，而在 RTT 变化较大的地方就不行了，因为平滑因子 α 的范围是`0.8 ~ 0.9`, RTT 对于 RTO 的影响太小。

### 标准方法

为了解决经典方法对于 RTT 变化不敏感的问题，后面又引出了标准方法，也叫`Jacobson / Karels 算法`。

一共有三步。

**第一步**: 计算`SRTT`，公式如下:

```
SRTT = (1 - α) * SRTT + α * RTT
```

注意这个时候的 `α`跟经典方法中的`α`取值不一样了，建议值是`1/8`，也就是`0.125`。

**第二步**: 计算`RTTVAR`(round-trip time variation)这个中间变量。

```
RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|)
```

β 建议值为 0.25。这个值是这个算法中出彩的地方，也就是说，它记录了最新的 RTT 与当前 SRTT 之间的差值，给我们在后续感知到 RTT 的变化提供了抓手。

**第三步**: 计算最终的`RTO`:

```
RTO = µ * SRTT + ∂ * RTTVAR 
```

`µ`建议值取`1`, `∂`建议值取`4`。

这个公式在 SRTT 的基础上加上了最新 RTT 与它的偏移，从而很好的感知了 RTT 的变化，这种算

## 9. Nagle 算法和延迟确认

### Nagle 算法

试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。

而避免小包的频繁发送，这就是 Nagle 算法要做的事情。

具体来说，Nagle 算法的规则如下:

-   当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送

-   后面发送满足下面条件之一就可以发了:

    -   数据包大小达到最大段大小(Max Segment Size, 即 MSS)
    -   之前所有包的 ACK 都已接收到

### 延迟确认

试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？

**延迟确认**(delayed ack)所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。

不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复:

-   接收到了大于一个 frame 的报文，且需要调整窗口大小
-   TCP 处于 quickack 模式（通过`tcp_in_quickack_mode`设置）
-   发现了乱序包

### 两者一起使用会怎样？

前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。

## 10. TCP的keep-alive?

大家都听说过 http 的`keep-alive`, 不过 TCP 层面也是有`keep-alive`机制，而且跟应用层不太一样。

试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。

这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。

在 Linux 下，可以这样查看相关的配置:

```
sudo sysctl -a | grep keepalive
​
// 每隔 7200 s 检测一次
net.ipv4.tcp_keepalive_time = 7200
// 一次最多重传 9 个包
net.ipv4.tcp_keepalive_probes = 9
// 每个包的间隔重传间隔 75 s
net.ipv4.tcp_keepalive_intvl = 75
```

不过，现状是大部分的应用并没有默认开启 TCP 的`keep-alive`选项，为什么？

站在应用的角度：

-   7200s 也就是两个小时检测一次，时间太长
-   时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接

因此是一个比较尴尬的设计。